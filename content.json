{"pages":[],"posts":[{"title":"Terminal &amp; Git 단축키","text":"Terminal 단축키 주로 사용할것이라고 생각하는 terminal 명령어를 정리 ls : 해당 디렉토리의 폴더 목록을 조회 12ls 현재 디렉토리명ls desktop cd : 이동하고 싶은 디렉토리로 경로 이동 12cd 이동하고 싶은 디렉토리 경로cd desktop pwd : 현재 디렉토리의 경로 확인 12pwd 현재 디렉토리 경로pwd desktop mkdir : 디렉토리 생성 12mkdir 디렉토리명mkdir testFolder rmdir : 디렉토리 삭제 12mkdir 디렉토리명mkdir testFolder touch : 파일 생성 12touch 파일명touch testFile.txt cp : 파일 복사 (폴더 복사는 안됨) 12cp 파일명cp testFile.txt mv : 파일 이동 12mv 파일명 파일 이동 경로mv testFile.txt ../desktop rm : 파일 삭제 12rm 파일명rm testFile.txt clear : 터미널의 셀 화면을 클리어 1clear exit : 화면 종료 1exit","link":"/2019/03/07/tech/git/2019-03-07-git-grammer/"},{"title":"Git이란 무엇일까?","text":"오늘은 패스트캠퍼스 IOS스쿨에서 배운 Git을 정리하면서 Git이란 무엇인지? 그리고 Git 사용의 이점이 무엇인지? 사용법은 어떻게 되는지에 대해서 포스팅해보려고 합니다. 먼저, Git이란 무엇일까?(참고 : https://git-scm.com/book/ko/v2 공식 사이트 한글 번역) 12프로그램 등의 소스 코드 관리를 위해 2005년에 개발된 분산 버전 관리 시스템(DVCS)리누스 토르발스가 BitKeeper 유료화에 자극받아 리눅스 커널 프로젝트에 사용하기 위해 개발 네트워크에 접근하거나 중앙 서버에 의존하지 않고도 사용 가능 이러한 Git은 1. 빠른 속도 2. 단순한 구조 3. 비선형적인 개발(수천 개의 동시 다발적인 브랜치) 4. 완벽한 분산 5. 리눅스 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서) 위와 같은 초기 목표를 탄생 이후 아직까지 유지가 되어가고있다. 이런 Git을 왜 사용하는것일까?공식홈페이지에는 다음과 같은 장점들을 가지고 있다. Branching and Merging Small and fast Distributed Data assurance Staging area Free and open source ✔︎ Branching and Merging Git가 다른 버전관리 프로그램들보다 가지는 가장 큰 장점은 branching 모델이다 Git은 로컬에 다수의 branch를 허용해주며, 각각에 대한 완벽한 독립성을 제공해주며 각 branch는 쉽게 생성/merge/삭제를 할 수 있다. 이러한 기능들로 인해 실험적인 코딩으로 인해 발생하는 오류들을 최소화하고 다시 원점으로 복귀하는 시간을 절약할 수 있다. ✔︎ Small and fast Git은 거의 모든 동작들을 로컬에서 우선적으로 실시하기 때문에 서버와 연동하기 위해 네트워크를 타지 않아도 되어서 속도면에서 엄청난 장점이 있다.그리고 속도와 성능은 git의 초기 목표이기도 하다. ✔︎ Distributed 모든 버전관리 프로그램들이 제공하는 또 다른 유용한 기능이 바로 어디서든지 checkout, git에서는 clone을 하면 바로 작업이 가능하다는 점이다. 이것은 메인 서버에 소스를 두고 여러 작업 환경에서 동시에 작업을 할 수도 있고, 각각의 작업환경에 따라서 다른 branch도 관리를 할 수 있게 되는 것이다. 각각의 작업환경에서 별도로 작업한 소스들은 언제든지 메인서버로 업로드하고 merge가 가능하며 git 특유의 로컬에서 많은 동작들을 수행하는 특징 때문에 이 분산 환경에서 제공하는 코딩은 더욱더 빛을 발하게 된다. ✔︎ Data assurance Git에서 사용하고 있는 데이터 모델은 모든 파일을 확실하게 암호화시켜주고 단 하나의 bit까지도 틀리지 않게 보관해준다. 모든 파일은 체크썸 검사를 하고, 다운을 받을 때에도 다시 실시를 하여 Git에서 모든 bit까지 보장을 해주게 된다. 또한 Git 저장소에 있는 파일이나 commit 메세지를 무단으로 수정하려면 commit할 때 부여하는 commit id가 바뀌기 때문에 내가 commit한 것인지 확실하게 보장할 수 있고, 히스토리 관리에도 유용하다. ✔︎ Free and open source Git는 GPLv2 오픈소스 라이센스를 사용해서 무료로 사용할 수 있다.","link":"/2019/03/07/tech/git/2019-03-07-whatIsGit/"},{"title":"Swift - 배열&amp;집합&amp;튜플&amp;딕셔너리","text":"배열 배열(Arrays)은 일련의 순서를 가지는 리스트 형식의 값을 저장하는 데에 사용되는 자료형 배열에 저장할 아이템의 타입에는 제약이 없지만, 하나의 배열에 저장하는 아이템 타입은 모두 같아야 한다. 선언 시 배열에 저장할 아이템 타입을 명확히 정의해야 한다. 배열의 크기는 동적으로 확장할 수 있다. 스위프트에서 배열읠 정의하는 방법으로는 두가지가 있는데, 정적(Static)인 방식과 동적(Dynamic)인 방식으로 나뉘어진다. 배열의 정적 선언 처음부터 배열을 구성하는 아이템을 포함하여 정의하는 방식으로 별도의 배열 선언이 필요 없다는 장점이 있다. 123456789101112[아이템1, 아이템2, 아이템3,...]var cities = [\"Seoul\", \"New York\", \"LA\", \"Santiago\"]cities[0] // Seoulcities[1] // New Yorkcities[2] // LAcities[3] // Santiagofor row in cities { let idx = cities.idx(of: row) //배열의 인덱스를 확인하여 index 상수에 대입 print(\"\\(idx!)번째 배열 원소는 \\(row)입니다\")} 배열의 동적 선언과 초기화 스위프트에서 배열을 정의하는 객체는 Array 이다. 이 Array를 정의할때 반드시 타입을 명시해야하는데 이때 타입을 지정하는 문법을 제네릭이라 한다. 동적으로 배열을 정의하는 형식 1 123456789Array &lt;아이템 타입&gt; ()// 문자열 배열의 선언 및 초기화var cities = Array&lt;String&gt;()// 문자열 배열을 선언var cities = Array&lt;String&gt;// 배열의 초기화cities = Array() 동적으로 배열을 정의하는 형식 2 123456789101112131415161718[ 아이템 타입 ] ()// case 1var cities : [String]() // 선언cities = [String]() // 초기화// case 2var country : [String] // 선언country = [] // 초기화// case 3var list : [Int] = [] // 타입 어노테이션 + 초기화// case 4var rows : Array&lt;Float&gt; = [Float]() //타입 어노테이션 + 제네릭 + 초기// case 5var tables : [String] = Array() // 타입 어노테이션 + 구방식의 초기화 배열 아이템 동적 추가 append(_:) 입력된 값을 배열의 맨 뒤에 추가 123var nickname = [\"pino\", \"raon\"]nickname.append(\"jinbae\")// [\"pino\", \"raon\", \"jinbae\"] insert(_:at:) 입력된 값을 원하는 위치에 직접 추가하고 싶을 때 사용 123var nickname = [\"pino\", \"raon\"]nickname.insert(\"jinbae\", at:1)// [\"pino\", \"jinbae\", \"raon\"] append(contentsOf:) 배열의 맨 마지막에 아이템을 추가하지만, 개별 아이템이 아니라 여러 개의 아이템을 배열에 한번에 추가할 때 사용하는 메소드로 인자값은 항상 배열이어야한다. 123var nickname = [\"pino\", \"raon\"]nickname.append(contentsOf: [\"jinbae\", \"Jeong\"])// [\"pino\", \"raon\", \"jinbae\", \"Jeong\"] 범위 연산자를 이용한 인덱스 참조 특정 범위의 인덱스에 해당하는 아이템을 모두 참조하여 한꺼번에 읽어 들일 때 사용 1234567var alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\"]alphabet[1...2] = [\"1\", \"2\", \"3\"]// alphabet = [\"a\", \"1\", \"2\", \"3\", \"d\", \"e\"]alphabet[2...4] = [\"A\"]// alphabet = [\"a\", \"1\" ,\"A\", \"e\"] 집합(Set) 스위프트에서 집합은 순서가 없는 중복되지 않는 값들의 컬렉션입니다. 딕셔너리처럼 집합에 포함된 값들에는 특정한 순서가 없으며 딕셔너리의 키(Key)처럼 집합은 중복된 값을 포함할 수 없습니다.스위프트의 다른 컬렉션 타입들과 마찬가지로 집합도 강한 타입 제약을 받습니다. 집합에는 지정된 한 가지 특정 타입의 값들만 담을 수 있다는 뜻입니다. 어떻게 보면 활용면에서의 제약으로 볼 수 있지만 실제로는 의도하지 않은 타입의 값을 넣어서 발생할 수 있는 버그와 문제들을 방지해 줍니다. 빈 집합의 생성 스위프트에서 집합을 생성하는 데에는 여러 가지가 방법이 있습니다. 그 중에 한 가지는 생성자 문법을 사용하는 것입니다. 1var genres = Set&lt;String&gt;() 모든 변수를 정의하는 것처럼 var 키워드를 사용하고 변수명 genres으로 가변(mutable)의 집합을 만들었습니다. 가변의 집합 변수를 정의하고 대입연산자(‘=’) 다음에 Set타입명을 지정했습니다. Set은 스위프트의 제네릭 자료형중의 한 가지입니다. 여기서는 String 자료형을 지정해서 이 집합이 문자열 String 타입의 엘리먼트들을 저장할 것이라는 것을 지정했습니다. 집합 순회 탐색 다른 컬렉션 타입과 마찬가지로 집합도 순차적으로 순회할 수 있습니다. 다만 주의해야할 사항은 엘리먼트의 순서를 보장하지 못한다는 점입니다. 12345678var genres : Set = [\"Classic\", \"Rock\", \"Balad\"]for g in genres { print(\"\\(g)\")}// Balad// Rock// Classic 엘리먼트에 순서를 지정하려면 sort() 함수를 통해서 값들을 정렬하여 그 결과를 순회하면 됩니다. 123456for g in genres.sorted(){ print(\"\\(g)\")}// Balad// Classic// Rock 집합의 동적 추가와 삭제집합에 엘리먼트를 추가하는 방법엘리먼트의 추가는 insert(:) 함수를 사용하면 됩니다.insert(:) 함수는 집합에 저장된 엘리먼트와 동일한 타입의 단일 파라미터를 입력 받습니다. (호환되지 않는 타입의 값을 사용하면 에러가 발생합니다.) 12345var genres = Set&lt;String&gt;()genres.count // 0genres.isEmpty // truegenres.insert(\"Jazz\") // genres에 Jazz 아이템 추가genres.count // 1 집합의 엘리먼트를 제거하는 방법12345// 특정 엘리먼트 삭제genres.remove(\"Rick\")// 전체 엘리먼트 삭제genres.removeAll() 집합 연산 12345678910111213141516var oddDigits : Set = [1, 3, 5, 7, 9]var evenDigits : Set = [0, 2, 4, 6, 8]var primeDigits : Set = [2, 3, 5, 7]// interSection(_:)oddDigits.intersection(evenDigits).sorted() // []// symmetricDifference(_:)oddDigits.symmetricDifference(evenDigits).sorted() // [1, 2, 9]// union(_:)oddDigits.union[evenDigits).sorted() // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]// subtract(_:)oddDigits.subtract(primeDigits)oddDigits.sorted() //[1, 9] isSubsetOf(_:) : 집합이 파라미터의 부분집합인지 True, False로 리턴 isSupersetOf(_:) : 집합이 파라미터의 상위집합인지 True, False로 리턴 isStrictSubsetOf(_:) : 집합이 파라미터의 부분집합인지 True, False로 리턴. 단, 파라미터와 같은 집합일 경우 False리턴 isStrictSupersetOf(_:) : 집합이 파라미터의 상위집합인지 True, False로 리턴. 단, 파라미터와 같은 집합일 경우 False리턴 isDisjointWith(_:) : 집합이 파라미터와 교집합이 없을 때 True를 리턴. 교집합이 있으면 False를 리턴. 12345678910let A : Set = [1, 3, 5, 7, 9]let B : Set = [3, 5]let C : Set = [3, 5]let D : Set = [2, 4, 6]B.isSubset(of: A) // trueA.isSuperset(of: B) // trueC.isStrictSubset(of: A) // trueC.isStrictSubset(of: B) // falseA.isDisjoint(with: B) // true 5.3 튜플(Tuple) Swift에서 제공하는 특별한 성격의 집단 자료형으로서, 타입과 관계없이 다양하게 저장할 수 있지만 최초에 선언된 상태의 아이템만 사용할 수 있고, 수정이나 삭제, 추가 등 변경할수 없는것이 튜플의 특징이다. 1234567891011121314151617let tupleValue = (\"A\", \"B\", 1, 2.5, true)tupleValue.3 // 2.5tupleValue.4 // truelet tuple = (1, \"Hello, world!\", true)let otherTuple = (1, (tuple))// 결과값을 튜플로 반환하는 함수func getTupleValue() -&gt; (String, String, Int){ return(\"t\", \"v\", 100)}// 함수가 반환하는 튜플을 튜플 상수로 바인딩let (a,b,c) = getTupleValue()// a ==&gt; \"t\"// b ==&gt; \"v\"// c ==&gt; 100 5.4 딕셔너리(Dictionary) 고유 키(Key)와 그에 대응하는 값(Value)을 연결하여 데이터를 저장하는 자료 12[ key : value, key : value, ...]Dictionary&lt;키의 타입, 값의 타입&gt;() 딕셔너리를 사용할 때 주의 사항 하나의 키는 하나의 데이터에만 연결 하나의 딕셔너리에서 키는 중복될 수 없다. 중복해서 선언하게 될 경우 추가가 아닌 수정이 이루어져 기존 키에 연결된 데이터는 삭제된다 저장할 수 있는 데이터 타입에는 제한이 없지만, 하나의 딕셔너리에 저장하는 데이터 타입은 모두 일치 딕셔너리의 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for~in 구문을 이용한 순회 탐색이 가능하다. KeyType은 해쉬가능한 타입어야합니다. Dictionary생성하는 방법KeyType이 Int고, ValueType이 String인 Dictionary를 생성하는 방법 1234var dic : [Int : String] = [:]var dic2 = [Int : String]()var dic3 : Dictionary = [Int:String]()var dic4 : Dictionary&lt;Int, String&gt; = Dictionary&lt;Int, String&gt;() 2. Dictionary 생성과 동시에 초기화12345var dic : [Int : String] = [1:\"pino\", 2:\"swift\", 3:\"iOS\"]var dic2 = [1:\"pino\", 2:\"swift\", 3:\"iOS\"]//타입유추. [Int:String]인 Dictionary구나var dic3 : Dictionary = [1:\"pino\", 2:\"swift\", 3:\"iOS\"]var dic4 : Dictionary&lt;Int, String&gt; = [1:\"pino\", 2:\"swift\", 3:\"iOS\"]//모두 [1:\"pino\", 2:\"swift\", 3:\"iOS\"]를 넣었지만, 출력이 이순서대로 된다고 보장할 수 없다. Dictionary는 순서가 없기때문 3. Dictionary 동적으로 아이템 추가1234var dic5 = [String:String]()dic5[\"nickname\"] = \"pino\" //[\"nickname\":\"pino\"]dic5.updateValue(\"Jinbae\", forKey: \"name\")print(dic5) //[\"nickname\" : \"pino\", \"name\" : \"Jinbae\"] 4. Dictionary 동적으로 아이템 삭제12dic5.removeValue(\"name\")print(dic5) // [\"nickanme\" : \"pino\"] 5. Dictionary 순회 탐색작성","link":"/2018/11/27/tech/swift/2018-11-27-Swift-%EB%B0%B0%EC%97%B4&%EC%A7%91%ED%95%A9&%ED%8A%9C%ED%94%8C&%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC/"},{"title":"Swift - 변수","text":"변수와 상수 > 변수와 상수는 값을 저장할 수있다는 공통점이 있지만, 상수는 한 번 저장된 값을 다른 값으로 변경할 수 없는 반면 변수는 필요에 따라 저장된 값을 몇 번이라도 다른 값으로 변경할 수 있다. 그래서 변수는 프로그램의 실행에 따라 변하는 값을 저장하고, 상수에는 변하지 않을 값을 저장한다. 1234567변수를 선언할 때 : var + 변수명: 변수타입ex) var year: Int = 1999 var message: String = \"Hello, Pino!\"상수를 선언할 때 : let + 변수명: 변수타입ex) let birthYear: Int = 1992birthYear = 1995 (상수여서 변경 불가 -&gt; 컴파일 오류 생김) 변수와 상수의 이름 정하기 - 알파벳과 한글 자음 및 모음, 아라비아 숫자를 사용할 수 있으며, 특수 기호나 한자, 이미지용 바이너리 코드까지 사용 가능하다. 12345// 영어 및 숫자, 언더바로 정의var str:String = \"문자열\"var initInt34: Int = 37var init_Int:Int = 100var ㅁaB수34☺️🛴❖:String = \"이것저것\" 연산자와 혼동할 수 있는[+, -, *, /] 및 공백은 변수, 상수명에 사용할 수 없다.(_는 사용 가능) 123456// 연산자와 공백은 변수나 상수명에 들어갈 수 없음.var abc+t = \"abc plus t\" // 연산자는 불가능var abc t = \"abc space t\" // 공백은 불가능// _는 사용 가능var abc_t = \"abc underbar t\" 스위프트에서 예약어나 키워드로 등록되어 있는 단어는 변수나 상수명에 사용할 수 없다.(대소문자를 바꾸어 사용은 가능) 1234567891011121314var class = 1 // 클래스 정의를 위한 키워드var enum = 2 // 열거형 정의를 위한 키워드var struct = 3 // 구조체 정의를 위한 키워드var extension = 4 // 확장을 위한 키워드var protocol = 5 // 프로토콜 정의를 위한 키워드var as = 6 // 타입 캐스팅을 위한 키워드// 단어의 일부를 대문자로 변경 후 사용 가능var Class = 1var Enum = 2var Struct = 3var Extension = 4var Protocol = 5var As = 6 변수, 상수명의 첫 번째 자리에 숫자가 올 수 없다. 12345var 1abc = 123var 2bcd = 345// 첫번째를 제외하고는 숫자가 들어갈 수 있다.var a1b2c3 = 123456 자료형 스위프트 언어에는다른 언어들에서 존재하는 대부분의 자료형이 존재합니다. 다만 우리가 익숙하게 배우는 C, C++, 그리고 JAVA(자바)와는 다르게 자료형의 첫 번째 철자를 대문자로 표현하고 있습니다. Int, Float, Double, Character, String, Array, Dictionary 등 첫 번째 스펠링을 대문자로 사용하고 있으며, 그 선언 방법이 앞에서 언급했던 언어들과는 조금 다릅니다. 그럼 예를 통해 살펴보도록 하겠습니다. 12345678910let int: Int = 0let float: Float = 0.0let double: Double = 0.0let char: Character = \"c\"let string: String = \"String\"let success = true || falselet array1: Array&lt;Int&gt; = [ 1, 2, 3, 4, 5 ]let array2: [Int] = [ 1, 2, 3, 4, 5 ]let dictionary1: Dictionary&lt;String, Int&gt; = [ \"string1\" : 1, \"string2\" : 2 ]let dictionary2: [String : Int] = [ \"string1\" : 1, \"string2\" : 2 ] 자료형 저장할 수 있는 값의 범위 크기 Int8 127 ~ -128 8bit Int16 32,767 ~ -32,768 16bit Int32 2,147,483,647 ~ -2,147,483,648 32bit Int64 9,223,372,036,854,775,807 ~ -9,223,372,036,854,775,808 64bit 타입 추론과 타입 어노테이션 swift는 데이터 타입에 매우 엄격하다. 서로 다른 데이터 타입끼리의 데이터 교환은 허용되지 않으며 캐스팅하여 형 변환을 해야 한다. 변수나 상수를 선언할 때 데이터 타입을 명시하지 않으면 알아서 컴파일러가 할당된 값을 기준으로 데이터 타입을 결정한다. 123456var year : Int = 1992var name : String = \"Pino\"var firstChr : Character = \"P\"var distance : Double = 78.8var pi : Float = 78.8var flag : Bool = true 타입 추론 VS 타입 어노테이션타입 어노테이션을 써야 할 경우는 아래 두 가지이다. 아래에 설명하는 상황 외에는 타입을 명시해주지 않아도 상관없지만 명시를 해도 오류는 없다. 선언과 초기화를 분리할 경우- 타입 추론은 초기화시 해당 값에 대한 타입이 정해지기 때문에 선언과 초기화를 분리하면 꼭 타입 어노테이션을 명시해야 한다. 1234//선언 + 타입 어노테이션var year : Int// 초기화year = 1999 타입 추론으로 얻어지는 타입이 아닌, 다른 타입을 직접 지정할 필요가 있을 때Int 대신 Float, Double 타입 1234var num1 = 4var num2 : Float = 4print(num1) // 4print(num2) // 4.0 String 대신 Character 타입 123456var value1 = \"String\" // Stringvar value2 = \"S\" // Character? String?print(value1) // Stringprint(value2) // Svalue2 = \"String2\" // value2 타입은 Stringprint(value2) // String 문자열이 아닌 문자 S를 담으려고 value2를 선언했지만value2는 String 타입이 되었다.Character 타입으로 선언하려면 타입을 명시해야 한다. Double 대신 Float 타입 Double와 Float는 값 오차가 차이가 있기 때문에 더 정확한 값을 필요로 한다면 Double로 타입을 명시해야 한다. 타입이 다른 변수끼리의 결합 123456var stmt = \"Pino의 키는\" // Stringvar height = 178 // Int//height Int를 String으로 타입 변환var stmtHeight = stmt + String(height)//Pino의 키는 178 문자열 템플릿 내부 계산 12345678// 상수와 변수 정의let apple = 3let banana = 2let orange = 4// 문자열 템플릿을 사용한 문자열 결합let desc = \"과일은 총 \\(apple + banana + orange)개입니다.\"print(desc) // 과일은 총 9개입니다.","link":"/2018/11/23/tech/swift/2018-11-23-Swift-variable/"},{"title":"Swift - 함수(Function)","text":"함수 함수 대부분은 작업의 가장 작은 단위이자 하나의 작은 프로그램이기도 합니다.“하나의 프로그램은 하나의 큰 함수다”라는 말이 있듯이, 함수는 프로그램을 이루는 주된 요소 중 하나입니다. 오늘은 이러한 함수에 대해서 포스팅 해보도록 하겠습니다. 함수는 상황이나 위치에 따라 다른 용어로 부르기도 하는데 구조체+, 클래스, 열거형 등 특정 타입에 연관되어 사용하는 함수인 메서드 모듈 전체에서 전역적으로 사용할 수 있는 일반 함수 로 구분되어 있습니다.즉, 함수가 위치하거나 사용되는 범위 등에 따라 호칭만 달라질 뿐, 함수라는 것 자체에는 변함이 없다는 뜻입니다. 이런 함수는 어떻게 선언하고 어떻게 호출을 할까요?함수의 기본형태는 다음과 같습니다. 123456func 함수명 (매개변수...) -&gt; 반환 타입 { 실행 구문 return 반환값} 하나씩 살펴보면 - 먼저 함수를 정의하는 키워드 func 작성 - 그 뒤에 함수명을 지정해준 후 매개변수는 소괄호()로 감싸줍니다 - 반환값이 있을 경우 -> 표시 후 어떤 타입이 반환될 것인지 명시해줍니다. (없을경우에는 생략 가능) - 그 후 실행구문을 작성하고 반환값이 있을 경우 `return 반환값` 을 작성해 줍니다. 매개변수매개변수란 함수를 정의할 때 외부로부터 받아들이는 전달 값의 이름을 의미하는데요스위프트의 함수는 매개변수를 어떻게 정의하냐에 따라서도 모습이 크게 달라질수 있습니다!어떻게 달라지는지 한번 알아볼까요? ✔︎ 매개변수가 없는 함수와 매개변수가 여러 개인 함수 함수에 매개변수가 필요 없다면 매개변수 위치를 공란으로 비워두면 됩니다. 123456func helloPino() -&gt; String { return \"Hello, Pino!!\"}print(helloPino())// Hello, Pino!! 출력 매개변수가 여러개 필요한 함수를 정의할 때는 ,로 매개변수를 구분하는데이 매개변수는 ```매개변수명: 매개변수 타입```으로 작성합니다. 123456func sayHello(myName: String, yourName: String) -&gt; String { return \"안녕하세요 \\(yourName)! 반갑습니다!! 저는 \\(Pino)입니다.\"}print(sayHello(myName: \"Pino\", yourName: \"여러분\"))// 안녕하세요 여러분! 반갑습니다!! 저는 Pino입니다. __✔︎ 매개변수 이름과 전달인자 레이블__ 위 함수를 보면 myName과 yourName이라는 매개변수 이름을 사용해서 함수를 호출했는데요이 매개변수 외에도 전달인자 레이블이라고 하는 친구를 별도로 지정해서 함수 외부에서 매개변수의 역할을 좀 더 명확하게 표현하고자 할 때 사용 가능합니다. 123456func welcome(from myName: String, _ name: String) -&gt; String { return \"어서오세요 \\(name)님! \\(myName)의 블로그에 오신것을 환영합니다!\"}print(welcome(from: \"Pino\", \"방문자\"))// 어서오세요 방문자님! Pino의 블로그에 오신것을 환영합니다! welcome의 호출 값을 보시면 매개변수만 있을 때와는 다르게 호출된다는게 보이실거에요 매개변수는 함수 내부에서만 사용 가능하고 전달인자 레이블은 함수 외부에서 사용할수 있습니다. 그리고 만약 전달인자 레이블을 사용하고 싶지 않다면 `_` 를 사용하여 생략이 가능합니다. __✔︎ 매개변수 기본값__ 외부에서 호출할수 있는 매개변수는 기본값을 지정하는것이 가능합니다. 12345678910func movieTime(_ movieName: String, time: Int = 3) -&gt; String { return \"\\(movieName)는(은) \\(time)시에 시작합니다.\"}print(movieTime(\"캡틴마블\"))// 캡틴마블는(은) 3시에 시작합니다.// 기본 값은 변경이 가능합니다.print(movieTime(\"캡틴마블\", time: 5))// 캡틴마블는(은) 5시에 시작합니다. __✔︎ 가변 매개변수와 입출력 매개변수__ 매개변수가 몇개가 들어올지 처음부터 알면 참 좋겠지만.. 코드를 쓰다보면 가변 매개변수가 몇개 들어와야될지 난감한 상황이 있는데이때 사용하는게 가변 매개변수입니다. 가변 매개변수는 타입 뒤 …를 사용하여 작성할수 있습니다.이 가변 매개변수는 0개 이상의 값을 받아올 수 있으며, 인자 값은 배열처럼 사용할수 있습니다. 123456789101112func whatIeat(me: String, foods names: String...) -&gt; String { var result: String = \"\" for food in names { result += \"\\(food)도 먹고 \" } return \"\\(me)는 \\(result)싶다\"}print(whatIeat(me: \"Pino\", foods: \"Steak\", \"Macaroon\", \"Americano\"))// Pino는 Steak도 먹고 Macaroon도 먹고 Americano도 먹고싶다 함수로 전달한 파라미터의 값을 함수 안에서 변경했을 때 변경된 값을 함수 밖에서 다시 참조하기 위해 스위프트에서는 ```inout``` 키워드를 사용합니다. 그리고 함수를 호출할 때 전달하는 변수 앞에 &를 붙여 사용합니다. inout 키워드는 함수에 변수를 전달하고 다시 그 변수를 참조할 수 있도록 하는데요. 코드를 보면 이해하기가 더 쉬울겁니다. 123456789func midnightSnack(food: inout String) { print(\"\\(food) 먹고싶다..\") food = \"피자\"}var food2 = \"족발\"midnightSnack(food: &amp;food2)// 족발 먹고싶다... 함수의 전달인자로 값을 전달할 때는 보통 Call By Value(값 복사)가 일어나 전달을 하게되는데 값에 의한 호출(Call by Value)와 참조에 의한 호출(Call by Reference)는 추후에 클래스와 구조체 포스팅 할때 따로 정리해서 포스팅 해놓겠습니다. 반환 타입위에 이미 몇번 코드상으로 언급은 했지만 다시 한번 반환 타입에 대해 간단히 언급하고 넘어가려 합니다.함수는 특정 연산을 실행후 결과값을 반환하는데요() -&gt; 타입을 통해 반환값이 있는 함수를 만들수도 있고, 반대로 결과값을 반환하지 않는 함수에서는() -&gt; Void를 사용해 반환값이 없음을 표시하거나 -&gt; Void를 생략하고 ()만 사용해서 함수를 나타냅니다. 1234567891011121314151617181920func studySwift() -&gt; String { return \"swift 공부를 합시다.\"}print(studySwift())// swift 공부를 합시다.func writePosting(who myName: String, what study: String) { print(\"\\(myName)는 블로그에 \\(study) 포스팅을 하고있습니다.\")}writePosting(who: \"Pino\", what: \"Swift\")// Pino는 블로그에 Swift 포스팅을 하고있습니다.func end() -&gt; Void { print(\"반환타입 끝!\")}end()// 반환타입 끝! Thanks for your reading, this article is provided by [Pino](https://github.com/92pino) If reproduced, please indicate the source： Pino（[https://github.com/92pino](https://github.com/92pino)）","link":"/2019/03/24/tech/swift/2019-03-24-Swift-Function/"},{"title":"Swift - 반복문 (Loop Statements)","text":"흐름 제어 구문 프로그래밍 과정에서 작성하는 소스 코드를 구문(Statement)라고 하고, 프로그램 실행 과정에서 실행 흐름을 능동적으로 제어하기 위한 목적으로 사용되는 구문을 흐름 제어 구문이라고 합니다. 오늘은 __흐름 제어 구문__ 중 __반복문__ 에 대해 포스팅하겠습니다. 구문은 크게 단순 구문과 흐름 제어 구문으로 나누어질수 있는데요 단순하게 식, 값 표현부터 각종 객체의 선언이나 정의, 심지어 변수나 상수 선언, 연산, 앞으로 포스팅 하게 될 함수나 구조체, 클래스, 열거형 등 모두 단순구문에 포함됩니다. 반면 흐름 제어 구문은 성격에 따라 다음과 같이 반복문 (Loop Statements) 조건문(Conditional Statements) 제어 전달문(Control Transfer Statements) 로 나누어집니다. 반복문반복이라는 건 간단하게 말해 ‘같은 일을 되풀이함’ 이라는 사전적 의미를 가지고 있는데요.만약 ‘Hello World’라는 단어를 1000번 이상 출력해야 하는데 사람이 하나하나 수작업을 한다면 실수나 오류가 날 확률이 높겠죠?이 때 사용하는 것이 반복문이라는 존재입니다.프로그래밍으로 주어진 조건에 의해 특정 코드 블록을 반복적으로 실행하는 구문이죠 Swift에서는 크게 두가지의 반복문이 존재합니다. 정해진 횟수만큼만 반복하는 For 반복문 주어진 조건이 false가 될 떄까지 계속해서 구문을 반복 실행하는 While 반복문 먼저 For 반복문에 대해 알아보겠습니다. For~in 구문가장 기본적인 For~in 구문은 다음과 같은 형태로 이루어집니다. 123for &lt;루프 상수&gt; in &lt;순회 대상&gt; { &lt;실행할 구문&gt;} 루프 상수루프상수는 구문이 반복될 때마다 순회 대상이 포함하고 있는 개별 아이템들을 차례로 넘겨받아 임의로 저장하고, 실행 블록 내에서 사용할 수 있도록 해주는 역할을 하는데요.루프 구문이 순회할 때마다 자동으로 재선언되므로 상수임에도 불구하고 let 키워드를 사용하여 직접 선언할 필요가 없습니다. 순회 대상주로 순번을 가지는 집단 자료형이나 범위를 가지는 데이터 등으로 이루어지는데, 순회 대상의 길이나 포함하고 있는 아이템의 개수만큼 구문이 반복 실행됩니다.순회 대상에 들어갈 수 있는 데이터 타입으로는 배열(Array), 딕셔너리(Dictionary), 집합(Set), 범위 데이터, 문자열(String)이 있습니다. for ~ in 구문의 가장 기본적인 예를 들면, 12345678910var lang = \"swift\"for char in lang.characters { print(\"개별 문자는 \\(char)입니다.\")}// 개별 문자는 s입니다.// 개별 문자는 w입니다.// 개별 문자는 i입니다.// 개별 문자는 f입니다.// 개별 문자는 t입니다. for ~ in 구문을 사용할 때 기본적으로는 루프 상수를 선언하여 값을 저장하고 사용할수 있게 해주는데 단순히 순회 대상의 크기만큼 반복하는 것이 목적일 경우 루프상수가 필요하지 않을 수도 있습니다. 이때에는 \\_를 사용하여 루프 상수를 생략할 수 있습니다. 123456789let size = 5let padChar = \"0\"var keyword = \"3\"for _ in 1...size { keyword = padChar + keyword}print(\"\\(keyword)\") While 구문앞에서 살펴본 forin 구문과 달리 while구문은 주어진 조건식의 결과가 false가 될 때까지 실행 구문을 계속 반복 수행하는데요.다시 말해 ‘조건을 만족하는 동안은 계속 실행’ 한다고 생각하시면 될것 같아요.같은 반복을 나타내는 두 구문이여서 어디에 사용될지 헷갈릴건데 while 구문을 사용해야 하는 몇가지 경우만을 제외하고는 대다수가 forin 구문으로 처리합니다. 실행 횟수가 명확하지 않을 때 직접 실행해보기 전까지는 실행 횟수를 결코 알 수 없을 때 실행 횟수를 기반으로 할 수 없는 조건일 때 while 구문은 다음과 같은 형태로 이루어집니다. 123while &lt;조건식&gt; { &lt;실행할 구문&gt;} 이런 while 구문에서도 주의해야 할 사항이 있는데요!! 그건 바로 조건식에 true값이 들어가서 한없이 반복 실행되는 무한 루프가 만들어질 수도 있습니다. 이 점만 주의하시면 while 구문을 사용하는데 큰 무리가 없을것입니다. 1234567var n = 2while n &lt; 1000 { n = n * 2}print(\"n = \\(n)\")// n = 1024 repeat~while 구문1234repeat { &lt;실행할 구문&gt;}while &lt;조건식&gt; swift에만 있는 문법으로 다른 언어에서는 do~while 구문에 해당하는 반복문입니다. 조건식을 먼저 평가하여 실행 블록의 수행 여부를 결정하는 while 구문과는 다르게 repeat~while 구문은 코드 블록을 일단 실행한 다음에 조건식을 평가하여 반복 여부를 결정합니다. 다시 말해 조건식이 false 여도 실행 블록이 최소 한번은 실행이 된다는 것입니다. 다음 예문을 보시면 이해가 빠르게 될것같은데요 12345678910var n = 1024repeat { n = n * 2}while n &lt; 1000print(\"n = \\(n)\")// n = 2048 조건식에서 이미 n은 1000을 넘는 값이지만 repeat 블록이 존재하므로 n = 2048이 출력되게 됩니다. 요약하자면, 12345✔︎ For~in 구문 : 횟수에 의한 반복✔︎ while 구문 : 조건에 의한 반복✔︎ repeat~while : 조건에 의한 반복이지만 조건이 fasle일 경우 최초 1번은 실행 Thanks for your reading, this article is provided by [Pino](https://github.com/92pino) If reproduced, please indicate the source： Pino（[https://github.com/92pino](https://github.com/92pino)）","link":"/2019/03/25/tech/swift/2019-03-25-Swift-LoopStatements/"},{"title":"Swift - 조건문 (Conditional Statements)","text":"흐름 제어 구문 프로그래밍 과정에서 작성하는 소스 코드를 구문(Statement)라고 하고, 프로그램 실행 과정에서 실행 흐름을 능동적으로 제어하기 위한 목적으로 사용되는 구문을 흐름 제어 구문이라고 합니다. 안녕하세요 Pino 입니다.오늘은 흐름 제어 구문 중 조건문 에 대해 포스팅하려합니다. 조건문우선 조건문이란 이름 그대로 “조건” 을 따지는 제어문인데요.특정한 조건 아래서만 코드가 실행되게 하는 구문을 말합니다.예를 들어 아이디와 비밀번호를 정확하게 입력했을 때 로그인이 가능하게 하는 상황에서 사용되겠네요. 이 조건문은 다른 언어에서와 마찬가지로 반복문과 함께 가장 기본적이라 볼수 있어요 Swift에서는 if, guard, switch가 가장 대표적입니다. if 구문if문은 if (조건식) { 실행내용 }으로 구성되는데요. 조건이 참일 경우에만 내용이 실행됩니다. 1234567var userId: String = \"pino\"if userId == \"pino\" { print(\"아이디가 일치합니다!!\")} else { print(\"아이디가 틀렸어요ㅠㅠ\")} userId라는 변수에 String 타입의 값 “pino”를 담고 조건식에서 userId와 조건식이 일치할 경우 “아이디가 일치합니다!!”라는 내용이 실행이 될거고, 일치하지 않으면 “아이디가 틀렸어요ㅠㅠ”라는 문구가 출력이 될것입니다. 여기에 만약 유저의 아이디를 받고 유저의 비밀번호까지 체크하려면 어떤 조건식을 써야하는지 알아볼까요? 123456789101112var userId: String = \"pino\"var userPw: Int = 1234if userId == \"pino\" { if userPw == 1234 { print(\"아이디와 비밀번호가 모두 일치합니다!\") } else { print(\"아이디는 맞는데 비밀번호가 틀렸네요ㅠㅠ\") }} else { print(\"아이디가 틀렸어요ㅠㅠ\")} userId가 참일 경우 userPw가 맞는지 체크하러 가는 조건을 추가해주면 간단하게 사용자의 아이디와 패스워드가 일치하는지 체크할수 있겠죠? 위 if문에서는 ```userId = \"pino\", userPw = 1234```가 모두 일치하므로 \"아이디와 비밀번호가 모두 일치합니다\"라는 문구가 출력이 되겠네요~ guard 구문다른 언어를 많이 안다뤄봤지만 guard구문은 Swift에만 있는 독특한 문법인것 같아요.if문과 동일하게 조건식의 결과가 참인지 거짓인지에 따라 구문의 실행 여부가 결정이 되는데 guard문 같은 경우 참일 때 실행되는 코드 블록이 없습니다.주로 guard문 뒤에 오는 코드들이 실행 되기 전에 심각한 오류가 있는지 확인을 하고 오류가 있을 경우 코드 진행을 막아주는 역할을 하고있어요. 123456789101112131415161718192021222324// userId를 옵셔널 값으로 처리해 nil이 나올수 있는 상황을 만들어줬습니다.var userId: String?var userPw: Int = 1234func checkIdPw() { // userId가 nil이 아닐 경우는 guard문 뒤에 코드 진행 // userId가 nil일 경우 guard문 내부 코드 진행 guard userId != nil else { print(\"아이디를 입력해주세요.\") return } if userId == \"pino\" { if userPw == 1234 { print(\"아이디와 비밀번호가 모두 일치합니다!\") } else { print(\"아이디는 맞는데 비밀번호가 틀렸네요ㅠㅠ\") } } else { print(\"아이디가 틀렸어요ㅠㅠ\") }}checkIdPw() 코드를 보면 userId에 nil값이 들어오면서 로그인을 할수 없는 오류 상황이 되니까 guard문에서 아이디를 입력하라는 메시지 출력과 동시에 함수를 막아버렸네요. 코드만 봐서는 guard와 if문의 차이가 크게 없어 보이는데요 guard문은 본래 실행 흐름을 종료하기 위한 목적으로 사용되는 구문이라 if문과 다르게 코드를 중첩해서 사용하지 않아도 되고 중첩 코드가 없으니 전체 코드가 더 깔끔하고 단순해지게 만들어주는 역할을 해요 switch 구문switch문은 경우에 따라 if문보다 더 적합한 때가 있습니다. 바로 몇 가지 선택지가 주어지고, 그에 대한 선택을 할 때죠. (“1. 프로그램 실행, 2. 대기, 3. 종료”처럼 선택지가 몇 가지 있다면 말이죠. ) 게임으로 예를 들어볼까요? 다들 롤이라는 게임은 아시죠?? 롤에는 5가지 라인이 있는데 플레이어마다 각 라인을 맡아 게임을 하게되는데요 5가지 라인 중 한 라인을 선택해서 플레이하게 되는 상황이 switch case문이라고 보면 될것 같습니다. 123456789101112131415161718var goToLine = \"AdCarry\"switch goToLine {case \"Top\": print(\"저는 탑 라이너니까 탑으로 가겠습니다.\")case \"Jungle\": print(\"저는 정글 라이너니까 정글로 가겠습니다.\")case \"Middle\": print(\"저는 미드 라이너니까 미드로 가겠습니다.\")case \"AdCarry\": print(\"저는 원딜이니까 봇으로 가겠습니다.\")case \"Support\": print(\"저는 서포터니까 봇으로 가겠습니다.\")default: print(\"저는 트롤이에요~~\")}// \"저는 원딜이니까 봇으로 가겠습니다.\" 코드를 보시면 Top, Jungle, Middle 이라는 선택지는 제가 가고 싶은 라인이 아니기에 지나쳤고 AdCarry 라인이 나오자 선택을 하고 Support라인은 관심을 안가졌네요? (그렇다고 트롤을 하시면 안되요..!!!) 이처럼 제가 선택한 조건과 나열된 조건이 일치할때까지 비교를 계속 하고 일치를 할 경우 선택을 하고 게임을 진행하는게 switch 구문이라고 할 수 있습니다. 만약 Top이라는 선택지를 선택했다면 case “Top”에서 선택이 되고 다른 라인들은 관심을 안가졌겠죠? 조건이 만족해도 다른 조건들을 한번씩 툭툭 건드려보는 다른 언어들과는 다르게 스위프트는 조건이 일치하는 순간 다음 조건들은 실행되지 않은 채로 조건문이 종료가 됩니다. 지금까지 조건문 3가지에 대해서 다뤄봤는데요 조건문은 제가 생각하기에 기초 프로그래밍에서 제일 중요한부분입니다조건문은 서로다른 환경에서 여러가지를 동시에 처리가 가능하게 해주기 때문이죠 그렇기에 조금더 많은 노력을 드려야 한다고 생각하는데요 자주 쓰이는 문법이니 여러 상황에서 사용할 수 있게 다양한 방법으로 코드 짜는 연습을 해봐야할거같네요 그럼 다음 포스팅때 뵙겠습니다~😀 Thanks for your reading, this article is provided by [Pino](https://github.com/92pino) If reproduced, please indicate the source： Pino（[https://github.com/92pino](https://github.com/92pino)）","link":"/2019/03/29/tech/swift/2019-03-29-Swift-ConditionalStatements/"},{"title":"$마크다운(Markdown) 사용법","text":"개발을 공부하다보면, 특히 깃허브(github)를 사용하면 마크다운(Markdown)의 필요성을 느끼게 됩니다. 깃허브에 자신이 올린 레포지토리에 관한 설명을 적을 때나, 도큐멘테이션 작업을 할 때 마크다운을 사용하게 되는데요. 현재 제가 작성중인 지킬(jekyll) 또한 마크다운으로 작성합니다. 오늘은 마크다운으로 문서를 정리할 때 꼭 필요한 문법들을 정리해보겠습니다. 제목(Heading)문서를 작성할 때 가장 기본이 되는 제목은 HTML의 &lt;h1&gt;~&lt;h6&gt; 태그와 유사합니다. #의 개수에 따라 글자의 크기가 달라집니다. #은 &lt;h1&gt;, ###은 &lt;h3&gt; ######은 &lt;h6&gt; 123# Heading### Heading###### Heading HeadingHeadingHeading본문(paragraph)HTML의 &lt;p&gt;와 같은 본문은 텍스트를 그대로 작성하면 됩니다. 1Lorem ipsum dolor sit amet, consectetur adipisicing elit Lorem ipsum dolor sit amet, consectetur adipisicing elit 인용(Blockquotes)인용은 &gt;를 넣어서 작성합니다. 12&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit&gt;&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit Lorem ipsum dolor sit amet, consectetur adipisicing elit Lorem ipsum dolor sit amet, consectetur adipisicing elit 리스트순서가 없는 리스트(Unordered List)* 또는 -를 사용해서 순서가 없는 리스트를 작성할 수 있습니다. tab 또는 2칸 띄어쓰기를 통해 중첩된 항목을 작성할 수 있습니다. 1234567891011* Frontend * HTML * CSS * JavaScript * Vue.js- Frondend - HTML - CSS - JavaScript - Vue.js Frontend HTML CSS JavaScript Vue.js Frondend HTML CSS JavaScript Vue.js 순서가 있는 리스트(Ordered List)1231. HTML2. CSS3. JavaScript HTML CSS JavaScript 1231. HTML1. CSS1. JavaScript HTML CSS JavaScript 1234561. Frontend 1. HTML 2. CSS 3. JavaScript 1. Vue.js2. Backend Frontend HTML CSS JavaScript Vue.js Backend 코드블럭(Code blocks)코드블럭은 일반 문장 사이에 단어, 짧은 문장 단위로 표현할 수 있는 방법과 여러줄의 코드를 삽입하는 방법이 있습니다. 단어, 한 줄의 코드를 감싸는 경우 `를 앞뒤로 감쌉니다. 1마크다운은 코드블럭을 `&lt;pre&gt;`와 `&lt;code&gt;`로 감쌉니다. 마크다운은 코드블럭을 &lt;pre&gt;와 &lt;code&gt;로 감쌉니다. 여러줄의 코드를 나타내는 코드블럭의 경우 코드블럭의 시작과 끝을 ```으로 감싸고 내부에 코드를 작성하면 됩니다. 123function square(n) { return n * n;} 수평선(Horizontal Rules)문단과 문단 사이를 나눌 때 등 사용되는 수평선은 HTML의 과 같이 동작합니다. 12345* * *********- - ---------------------------------------- 링크(Links)HTML의 하이퍼링크와 같은 링크는 다음과 같이 작성합니다. title은 생략이 가능합니다. 123[example](http://example.com \"title\")검색엔진은 [구글](https://www.google.com \"구글\")을 사용합니다. example 검색엔진은 구글을 사용합니다. 강조(Emphasis)HTML의 &lt;em&gt;과 같은 동작을 하는 강조는 *, _가 있고 &lt;strong&gt;은 **와 __를 사용합니다. 취소선은 ~~을 사용합니다. 12*강조*한 텍스트_강조_한 텍스트 강조한 텍스트 12**강조**한 텍스트__강조__한 텍스트 강조한 텍스트 1~~취소~~한 텍스트 취소한 텍스트 이미지 삽입(Images)이미지는 역시 HTML의 &lt;img&gt;태그와 동일하게 작동합니다. 대체 택스트를 삽입할 수 있으며, 링크 또는 로컬의 이미지파일을 연결할 수 있습니다. 12![대체 텍스트](/경로/example.jpg)![대체 텍스트](링크) 1![Github](./public/img/3/github.png) 1![Github](https://assets-cdn.github.com/images/modules/open_graph/github-octocat.png) 이상으로 마크다운의 기본 문법에 대해 알아봤습니다. 참고문헌 존 그루버의 Markdown: Syntax","link":"/2018/11/20/tech/theory/2018-11-19-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4(markdown)%20%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"title":"Swift-값타입과 참조타입","text":"값 타입과 참조 타입 https://developer.apple.com/swift/blog/?id=10 Swift의 타입은 크게 두 부류로 나뉘는데, 하나는 “값 타입”으로 각각의 인스턴스가 고유한 데이터의 사본을 가지고 있는 것으로 주로 구조체나 열거타입, 튜플등이 이에 해당된다. 다른 하나는 “참조 타입”으로 이는 각각의 인스턴스가 하나의 데이터 사본을 동시에 참조하는 것으로 클래스의 인스턴스가 여기에 해당한다. 이 글에서는 각 타입의 장점과 언제 어떤 타입을 사용해야 할지를 알아보겠다. 차이점값타입이 참조타입과 구분되는 가장 큰 특징은 복사 — 대입, 초기화, 파라미터로 전달 –가 되어 개별 이스턴스들이 각각의 독립된 사본으로 존재하게 되는 것이다. 12345struct S { var data: Int = -1 }var a = S()var b = aa.data = 42println(\"\\(a.data), \\(b.data)\") // \"42, -1\" 레퍼런스를 복사하는 것은 암시적으로는 공유된 인스턴스를 갖는 것이다. 따라서 복사 후에도 두 인스턴스는 동일한 데이터이며, 두 번째 인스턴스를 변경하는 것은 원본에도 영향을 준다. 12345class C { var data: Int = -1 }var x = C()var y = xx.data = 42println(\"\\(x.data), \\(y.data)\") // \"42, 42\" 변경과 안정성레퍼런스 타입보다 값 타입을 사용하는 가장 주된 목적은 코드를 이해하기 쉽다는 것이다. 각 인스턴스가 독립된 데이터 사본을 가지고 있다는 것은, 보이지 않는 곳에서 해당 데이터가 임의로 변경되지 않음을 보장할 수 있다는 것이다. 특히 이는 멀티스레드 환경에서 다른 스레드가 예기치 못한 시점에 데이터를 변경해놓을 수 있는 것을 방지한다. 보통 이런 류의 문제는 디버깅이 극히 어렵다. 이 차이점은 값이 변경될 때 두드러지므로, 만약 변경가능한 데이터가 없다면 클래스와 구조체의 차이가 없어진다. 즉 변경이 없으면 값타입이나 참조타입은 기본적으로 동일하다. 만약 클래스가 전적으로 변경불가한 속성을 갖고 있을 때를 가정해보자. 실제로 Swift에서는 읽기만 가능한 프로퍼티를 사용하고, 값을 바꾸는 API를 노출하지 않음으로써 변경 불가한 클래스를 만들 수 있다. Cocoa에서 NSURL이 이런 변경 불가한 클래스이다. 하지만, Swift는 원칙적으로 현재는 클래스를 변경 불가하도록 강제하는 언어적 매커니즘을 가지고 있지 않다. 따라서 완전히 변경 불가한 것을 보장하려한다면 구조체나 열거타입을 사용해야 한다. 선택새로운 타입을 만들 때 값타입과 참조 타입 중 어떤 것을 선택해야 할까? Cocoa를 사용한다면 많은 API들은 NSObject의 서브 클래스일 것이다. 따라서 class를 사용해야 한다. 다른 경우라면, ==를 사용하여 인스턴스를 비교하는 것이 합당하다면 독립적인 상태로 각각의 사본을 만들고자 한다면 여러 스레드에서 사용될 데이터라면 값 타입을 사용해야 한다. 그리고, ===를 사용하여 인스턴스(포인터)를 비교하는 것이 합당하다면 공유된 상태, 변경이 가능한 상태를 원한다면 클래스를 쓰면 된다. Swift에서 Array, String, Dictionary는 모두 값 타입이다. 이는 C의 int 타입처럼 순수한 값처럼 동작한다. 특별히 명시적으로 구조 내부를 복사하는 코드를 만들 필요가 없으며, 뒷단에서 다른 코드에 데이터를 불지불식간에 변경하는 일도 없다. 특히 값타입은 동기화 없이 스레드 간에 데이터를 전달할 수 있다. 따라서 안정성을 높이는 관점에서 바라볼 때 이런 모델은 코드를 보다 더 예측가능하게 만들어 줄 것이다.","link":"/2018/12/01/tech/theory/2018-12-01-%5Bswift%5D%20%EA%B0%92%ED%83%80%EC%9E%85%EA%B3%BC%20%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85/"},{"title":"객체 지향 프로그래밍(OOP)이란?","text":"프로그래밍```을 공부하면서 첫 장에 객체 지향 프로그래밍에 대한 설명이 나와있어서 프로그래밍을 배워 나가기 위해서는 꼭 필요한 프로그래밍 방법이라 정리를 한번 하려 한다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687## 객체 지향 프로그래밍(OOP)이란 무엇일까?&gt; 객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나로써, 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위인 &quot;객체&quot;들의 모임으로 파악하고자 하는 것으로 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있습니다.## 이런 객체 지향 프로그래밍의 장점과 단점은 무엇이 있을까?- 장점 - 대규모 소프트웨어 개발에 적합 - 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러 회사에서 개발이 필요할 시 업무 분담하기가 쉽다. - 유지보수가 쉽다. - 절차 지향 프로그래밍에서는 코드를 수정해야 할 때 일일이 찾아 수정해야 하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 된다. - 코드를 재사용하기가 편하다. - 다른 사람이 만든 클래스를 가져와 이용할수 있고 상속을 통해 확장해서 사용할 수 있다. - 코드가 간단하다.- 단점 - 처리 속도가 상대적으로 느리다. - 객체가 많으면 용량이 커질 수도 있다. - 설계시 많은 시간과 노력이 필요하다.위와 같은 장점과 단점이 있는 객체 지향 프로그래밍 패러다임이지만, 지나친 프로그램의 객체화 경향 때문에 오히려 실제 세계의 모습을 그대로 바영하기 어렵다는 비판을 받기도 한다.## 객체 지향 구성 요소- 클래스(class) &gt; - 같은 종류(또는 문제 해결을 위한)의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user define data type)이라고 할 수 있다. 클래스는 프로그래머가 아니지만 해결해야 할 문제가 속하는 영역에 종사하는 사람이라면 사용할 수 있고, 다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다. &gt; - 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것- 객체(Object) &gt; - 클래스의 인스턴스(실제로 메모리상에 할당된 것)이다. 객체는 자신 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있다. 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용한다. &gt; - 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것- 메서드(Method), 메시지(Message) &gt;클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 메시지라 할 수 있다. 메서드는 한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는 데 사용된다. 또 객체 간의 통신은 메시지를 통해 이루어진다.## 특징1. 캡슐화(Encapsulation) - 캡슐화의 목적 : 코드를 재수정 없이 재활용 하는 것. - 기능과 특성의 모음을 &quot;클래스&quot;라는 &quot;캡슐&quot;에 분류해서 넣는 것이 캡슐화이다. - 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.2. 상속(Inheritance) - 상위(부모) 객체의 필드(속성)와 메소드를 하위(자식) 객체에게 물려주는 행위 - 하위 객체는 상위 객체를 확장해서 추가적인 필드(속성)와 메소드를 가질 수 있음 - 하위 객체에서 상위객체의 필드와 메소드를 따로 또 만들어서 사용할 필요가 없으며 상위 객체의 메소드에 문제가 있을 경우 상위 객체에서의 수정으로 인해 하위객체에서 문제가 있었던 메서드를 따로 수정할 필요없이 메서드를 사용할 수 있다.3. 자료 추상화 - 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.4. 다형성 - 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석 될 수 있다는 것이다. - 일반적으로 오버라이딩, 오버로딩을 의미한다. - 오버라이딩 : 같은 이름의 메서드가 여러 클래스에서 다른 기능을 하는 것 - 오버로딩 : 같은 이름의 메서드가 잉ㄴ자의 갯수나 자료형에 따라서 다른 기능을 하는 것## 객체 지향 프로그래밍 원칙객체지향에서 꼭 지켜야 할 5개의 원칙을 말하는 것으로 5개의 원칙의 앞글자를 따서 SOLID라고도 부른다.1. SRP : 단일 책임 원칙 (Single responsibility principle) - 객체는 하나의 책임만을 맡아야 한다. 다시 말하면 클래스를 수정할 이유가 오직 하나여야 한다는 뜻이다. - 성능저하라는 부작용이 없어 DB 정규화와 비슷하다 ### [사례] - 데이터 매퍼 패턴(DAO)2. OCP : 개방 - 폐쇄 원칙 (Open Closed Principle) - 확장에 대해서는 개방 되어 있어야 하지만, 수정에 대해서는 폐쇄 되어야 한다. ### [사례] - 상속과 어댑터 클래스를 통한 클라이언트 클래스 접속 - 컴파일러, POSIX 표준3. LSP : 리스코프 치환원칙 (Liskov Substitusion Principle) - 자식 클래스는 언제나 자신의 부모클래스를 교체할 수 있다는 원칙 - 부모클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것 - 업캐스팅을 해도 아무런 문제가 안되어야 한다는 것이다. 쉽게 설명외더 있는 내용을 가져와 보았다. 도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스의 상속을 받는다고 가정하자. (1) 도형은 둘레를 가지고 있다. (2) 도형은 넓이를 가지고 있다. (3) 도형은 각을 가지고 있다. 일반화 관계(일관성인지 확인하는 방법은 단어를 교체해 보면 알 수 있다. (1) ~ (3)의 도형이란 단어 대신 사각형을 넣어보자. (1) 사각형은 둘레를 가지고 있다. (2) 사각형은 넓이를 가지고 있다. (3) 사각형은 각을 가지고 있다. (1) ~ (3) 모두 딱히 이상한 부분이 보이지 않는다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다. 여기서 원(Circle) 이라는 도형에 대해 생각해보자. 원 클래스 역시 도형 클래스의 상속을 받는다고 가정하자. 앞에서 언급한 (1) ~ (3)의 도형 단어 대신 원을 대입해보자. (1) 원은 둘레를 가지고 있다. (2) 원은 넓이를 가지고 있다. (3) 원은 각을 가지고 있다. 문장을 읽어보면 (3)번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP을 만족하지 않은 설계라 할 수 있다. 따라서 (3)문장에 대해서는 일반화 관계가 성립하도록 수정되어야 한다. ``` ISP : 인터페이스 분리 원칙 (Interface Segregation Principle) 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙. 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다. DIP : 의존성 역전 법칙 (Dependency Inversion Principle) 상위클래스는 하위클래스에 의존해서는 안된다는 법칙. 하위클래스가 상위클래스에 의존을 해야지 상위클래스가 하위클래스에 의존한다는 것은 말도안되는 소리이다.","link":"/2019/03/09/tech/theory/2019-03-09-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5(OOP)/"},{"title":"코코아 프레임워크 VS 코코아 터치 프레임워크","text":"안녕하세요 Pino 입니다.오늘은 코코아 프레임워크 vs 코코아 터치 프레임워크 에 대해 포스팅하려합니다. 처음 공부를 시작할때 부터 코코아 라는 단어를 많이 들었었는데요{: width=”200” height=”200”}(이 코코아는 아닌거같은데…) 우선 코코아 란 무엇일까요?? Cocoa란 애플에서 판매하던 하드웨어 매킨토시의 어플리케이션을 개발하기 위해 사용되던 프레임워크가 바로 ```Cocoa Framework```입니다. 애플 제품을 사용하는사람과 ios개발을 하는 사람이라면 누구나 사용하는 ```사파리(Safari)```, ```Xcode```가 대표적인 예시인데요 ![](https://user-images.githubusercontent.com/45158632/55285166-16edfd80-53c1-11e9-9fca-2e78a7c63d7e.jpg){: width=\"500\" height=\"200\"} 심지어 제어버튼 마저도 코코아 프레임워크 입니다.우리가 직접 구현해주지 않아도 코코아 프레임워크에서 제공하는 NSWindow라는 객체를 사용하여 윈도우를 생성하면 자동으로 추가되는 기능입니다. Cocoa framework의 양대 산맥, Foundation과 AppKitApple이 제공하는 Framework의 종류는 매우 많습니다만, 가장 핵심이 되는 Framework는 2가지 입니다. Foundation Framework AppKit Framework Foundation FrameworkFoundation은 원시 데이터 타입(String, Int, Double), 컬렉션 타입(Array, Dictionary, Set) 및 운영체제 서비스를 사용해 애플리케이션의 기본적인 기능을 관리하는 프레임워크 입니다. Foundation 프레임워크는 데이터 타입, 날짜 및 시간 계산, 필터 및 정렬, 네트워킹 등의 기본 기능을 제공합니다. Foundation 프레임워크에서 정의한 클래스, 프로토콜 및 데이터 타입은 iOS뿐만 아니라 macOS, watchOS, tvOS 등 모든 애플 SDK에서 사용됩니다. AppKit FrameworkMac OS X에서 Foundation과 함께 Cocoa의 핵심을 이루는 또 하나의 Framework는 Application Kit입니다. 보통 AppKit라고 많이 얘기하는데, 주로 유저 인터페이스에 관련된 기능을 제공하며 Foundation과 마찬가지로 NS로 시작하는 클래스들을 가지고 있습니다. 우선 코코아터치 란 무엇일까요??Cocoa Touch라고 불리는 것은 iOS 애플리케이션 개발 환경으로, 애플리케이션의 다양한 기능 구현에 필요한 여러 프레임워크를 포함하는 최상위 레벨의 프레임워크입니다. ‘코코아’라는 단어는 Objective-C 런타임을 기반으로하고, NSObject를 상속받는 모든 클래스 또는 객체를 가리킬 때 사용합니다. ‘코코아’ 또는 ‘코코아 터치’는 iOS 또는 macOS의 전반적인 기능을 활용해 애플리케이션을 제작할 때 사용하는 프레임워크입니다. ‘코코아 터치’는 핵심 프레임워크인 UIKit과 Foundation을 포함합니다. Cocoa Touch framework의 양대 산맥, Foundation과 UIKitUIKit FrameworkUIKit은 iOS 애플리케이션의 사용자 인터페이스를 구현하고 이벤트를 관리하는 프레임워크입니다. UIKit 프레임워크는 제스처 처리, 애니메이션, 그림 그리기, 이미지 처리, 텍스트 처리 등 사용자 이벤트 처리를 위한 클래스를 포함합니다. 또한 테이블뷰, 슬라이더, 버튼, 텍스트 필드, 얼럿 창 등 애플리케이션의 화면을 구성하는 요소를 포함합니다. UIKit 클래스 중 UIResponder에서 파생된 클래스나 사용자 인터페이스에 관련된 클래스는 애플리케이션의 메인 스레드(혹은 메인 디스패치 큐)에서만 사용하세요. UIKit은 iOS와 tvOS 플랫폼에서 사용합니다.","link":"/2019/03/30/tech/theory/2019-03-30-CocoavsCocoaTouch/"},{"title":"TIL - 20190322","text":"Today I Learned2019.03.22 (금) ✔︎ App Life Cycle (앱 생명주기) 조만간 App Life Cycle과 AppDelegate에 대해 포스팅을 해봐야겠다. 추가로 메모리도!! ✔︎ AppDelegate ?? 각각의 상태에 접근하기 위해 사용되는 파일이라고 하는데 각각의 메서드에 따라 앱의 호출 시기가 다르다. 추후에 실제 앱 개발을 하면서 많이 볼 화면중 하나라고 생각든다. ✔︎ @IBOutlet, @IBAction 만드는 방식 ✔︎ Xcode 단축키 주로 사용하는 단축키들 Cmd + option + enter : 화면 분할 Cmd + enter : 화면 합치기 Cmd + R : 시뮬레이터 실행 Cmd + Shift + H : 시뮬레이터에서 홈화면으로 가는 단축키 Cmd + K : 로그창 clear 단축키는 더 많지만 나중에 추가적으로 정리 필요할듯.. ✔︎ Xcode 다뤄보기 ✔︎ Entry Point 스토리보드 상에서 한번 설정한 후 코드가 익숙해지기 전까지 스토리보드로 이벤트 작성하는 것과 코드로 작성하는것 두가지를 병행 해야될것같다.ps) 다음주 시험이니까 UI도 중요하지만 시험공부도 병행 필요 ==&gt; 문법 정리","link":"/2019/03/22/tech/til/2019-03-22-TIL20190322/"},{"title":"TIL - 20190308","text":"Today I Learned2019.03.08 (금) ✔︎ 맥북에서 사용하기 좋은 프로그램 &amp; 앱에 대한 종류와 사용법(여러가지 종류를 알려주셨는데 그중에 유용할것 같다고 생각하는 것들만 정리해놓으려한다.) Chrome프로그래밍을 하는 사람들이라면 기본적으로 다운 받아야되는 웹브라우저인것 같다. spectacle윈도우에 내장되어있는 화면 분할과 동일한 기능인데 다만 단축키가 많이(?) 다르다는것을 제외하면 화면 분할 프로그램으로 사용하기에는 제일 좋은것 같다! keka\u001c맥용 알집?이라고 보면 될것 같다. 아직까지 사용해보진 못해서 어떠한 기능과 장점이 있는지는 잘 모르겠지만 쓰다보면 장점이 있지 않을까한다. Typora깃헙이나 블로그를 운영하면서 제일 자주 사용될것 같은 Typora!!마크다운 문법을 지원해주는 에디터다보니 자주 사용할 것 같다 Alfredspotlight와 비슷한 기능인데 자주 가는 사이트나 프로그램을 커스텀하여 사용하다보면 스팟라이트보다 훨씬 편하게 사용할 수 있을것같다. Skitch깃헙이나 블로그를 사용하는 것 외에도 이미지를 캡쳐해서 메모를 작성하거나 ppt자료에 관련된 이미지를 편집하는데에 많이 사용될것 같은 프로그램?? [ 유료 ] BetterTouchTool유료여서 사용을 해야될지 말아야될지 모르겠고, 정확히 어떤 프로그램인지 사용을 안해봐서 작성하기에는 애매한것같다..짧은 기간동안 무료 버전이 있으니 기간 동안 사용해보며 남겨봐야될것같다. Duet Display듀얼 모니터 연걸 프로그램 ✔︎ 구글 검색을 더 잘하는 법몇가지 명령어를 사용하여 더 효율적인 구글 검색 방법을 배운것 같다. 원래 네이버에서 쓰던 단순한 키워드나 문장으로 검색하는 방법이 아닌 명령어를 추가해서 검색하는 방법을 더 연습해야겠다! site:[url] 지정한 사이트를 한정하여 해당 사이트에 대한 검색결과만 출력 [ex] http site:w3schools.com http site:org intitle:[keyword], intext:[keyword] 키워드가 제목에 포함된 경우만 출력.본문의 경우는 intext 사용 [ex] iOS site:org intitle:swift iOS intext:objective-c filetype:[extension] 지정한 확장자 파일만 검색 [ex] baseball filetype:pdf iOS filetype:text exact phrase 해당 문장을 통째로 검색에 반영하며 정확히 일치하는 결과만 검색 [ex] “사느냐 죽는냐 그것이 문제로다” 오타가 나면 보통 구글이 다른 검색어를 추천해주지만 쌍따옴표를 넣은 경우 그대로 검색이 된다. [keyword] or [keyword] [ex] piano or guitar 피아노 또는 기타에 대해서 검색한 결과 출력 [keyword] - 지정키워드와 관련된 결과를 제거 검색 결과중 키워드와 관련된 결과 제거 [ex] salsa -dancing swift -apple [keyword] +지정키워드 필수 포함 검색을 하되 키워드와 관련되거나 포함된 결과만 출력 [ex] 애플 +아이폰 애플에 대해 검색하되 아이폰과 관련된 키워드가 포함된 결과만 출력 [keyword] * [keyword] 기억이 나지 않거나 키워드 사이에 포함되는 모든 단어를 결과에 포함하고 싶을 때 사용 [ex] 동해물과 * 마르고 닳도록 ~[keyword] 키워드와 동의어, 유사어에 대해서도 함께 검색 [ex] ~alternative energy ✔︎ 참고 링크 Google Search Education How to Search on Google: 31 Google Advanced Search Tips ✔︎ 맥북 캡처 방법 원래 알고있던 command + shift + 4 외에도 해당 영역만 캡쳐하는 법 등 다양한 방법을 알게된것같다! 거기에다가 프로그램까지 사용하게되면 블로그를 사용할 때 더 다양한 캡쳐를 할수 있을것같다. 사전과제 시험을 봤는데… 공부를 너무 안하고 놀았던게 확실히 표시가 나는것 같다… 문제 다시 정리해보고 이해 해야겠다.","link":"/2019/03/08/tech/til/2019-03-08-TIL20190308/"},{"title":"TIL - 20190330","text":"Today I Learned2019.03.30 (토) UI,UX특강 ✔︎ 웹/앱 서비스 개발 프로젝트 단계 기존에 알고있었던 단계이지만 각 단계마다 어떤 특징이 있는지 어떻게 디자인하고 어떻게 개발,배포하는지에 대한 상세한 설명을 들었던것 같다. 다른 클래스는 큰 도움이 안된거같다고 들었는데 IOS스쿨 사람들한테는(아무래도 특강 강사님이 ios스쿨 출신이시다보니??) 대부분의 예시가 ios관련 예시여서 이해하기 굉장히 쉬웠던것같다. ✔︎ 웹·모바일 UI/UX 간단하게만 알고있었던 UI/UX였는데 설명을 자세히 해주셔서 그런지 UI/UX가 뭔지 다시는? 안까먹을거같다!! 이번 시간에도 역시 예시는 앱 화면을 기준으로 해주셨다(다른스쿨한테는 미안하지만) 앱에 대한 정확한 가이드를 듣고 참고 사이트도 알게되어서 역시 좋군!!!!!! 무조건 봐야할 사이트!!! Human Interface Guidelines 해커톤, 팀 프로젝트때 사용하게 될 스케치라는 프로그램과 그에 따라 참고해야 될 사이트들을 받았다 앱디자인 관련 사이트 ui8, Sketch App Sources, icons8 ✔︎ UI/UX 기초 레이아웃, 그리드, 앱 디자인 각 섹션 별 용어 설명 및 기능 설명, 애플 휴먼 인터페이스 가이드라인에서 Reject 당하지 않게 하는 사항들 ✔︎ 토요일 하루를 빼고 가는 특강이고 UI/UX에 대해 크게 필요없다고 생각하고 갔었는데 생각 외로 좋은 특강이였다고 생각하고 앞으로 프로젝트 하는데 도움이 많이 되는 내용들만 받은것 같다! 다음번에도 특강 오시던데 그때는 더 집중해서 수업들어야될듯!!","link":"/2019/03/30/tech/til/2019-03-30-TIL20190330/"},{"title":"TIL - 20190325","text":"Today I Learned2019.03.25 (월) ✔︎ UIGuide Frame, bounds, Iphone Resolutions, iOS Device Screen Geometry 참고 사이트 : Apple Human Interface Guidelines ✔︎ ImageRendering 참고 사이트 : ios-layout-guideline ✔︎ AlertActive 팝업창이라고 보면 될것 같은데 팝업창에 버튼 &amp; 텍스트필드를 만들어서 값을 반환하는것에 대해 배웠는데 간단하게는 만들수있지만 옵셔널에 대한 스터디가 더 필요하다는 것을 깨달았다. 제드님 블로그에 Alert View 사용해보기 포스트가 있길래 참고 해보면 좋을 것 같다.(역시 정리를 엄청 잘하시는데 배울 점 중 하나인것같다.) 왕초보를 위한 Alert View - zedd님","link":"/2019/03/25/tech/til/2019-03-25-TIL20190325/"},{"title":"TIL - 20190331","text":"Today I Learned2019.03.31 (일) ✔︎ 코코아 프레임워크 vs 코코아 터치 프레임워크 차이점 코코아 프레임워크 vs 코코아 터치 프레임워크 ✔︎ 뷰 컨트롤러의 상태 변화와 생명 주기 Appearing : 뷰 컨트롤러가 스크린에 등장하기 시작한 순간부터 등장을 완료하기 직전까지의 상태 Appeared : 뷰 컨트롤러가 스크린 전체에 완전히 등장한 상태 Disappearing : 뷰 컨트롤러가 스크린에서 가려지기 시작해서 완전히 가려지기 직전까지의 상태 Disappeared : 뷰 컨트롤러가 스크린에서 완전히 가려졌거나 혹은 퇴장한 상태 ✔︎ IBOutlet Storage에서 Strong/Weak 메모리 회수 정책 차이 추후에 깊게 공부 필요할듯","link":"/2019/03/31/tech/til/2019-03-31-TIL20190331/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"Theory","slug":"Theory","link":"/tags/Theory/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"}],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"swift","slug":"swift","link":"/categories/swift/"},{"name":"theory","slug":"theory","link":"/categories/theory/"},{"name":"til","slug":"til","link":"/categories/til/"}]}